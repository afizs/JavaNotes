---
layout: post
title: Constructors
---

Objects are constructed. You can never make a new object without invoking a constructor (and not just the
constructor of the object's actual class type, but also the constructor of each of its superclasses).

Suppose there is a `Horse` class which extends `Animal` (and obviously `Animal` extends `Object`). Now this is how the
constructors are called after `new Horse()` is invoked from `main()`:

-----------------------------|
1.  main() calls new Horse() |
2.  Horse() calls super()    |
3.  Animal() calls super()   |
4.  Object()                 |


Constructors __have no return type__ and their __names must exactly match the class name__. Typically, constructors
are used to initialize instance variable as below:

{% highlight java linenos %}
class Foo {
     int size;
     String name;

     Foo(String name, int size) {
        this.name = name;
        this.size = size;
     }
}
{% endhighlight %}

So when you invoke  __`new Foo("rohit", 12)`__, an object of `Foo` class is created with `name` set as `Rohit` and `size`
as `12`.

### Below are the important rules for Constructors

__1.__ If you don't type a constructor into your class code, a default constructor will be automatically generated by
the compiler. The __default constructor (the one supplied by compiler) is ALWAYS a no-arg constructor__.

<table>

<tr>
<th>
Class Code (WhatYouType)
</th>
<th>
Compiler Generated Constructor Code
</th>
</tr>



<tr>
<td>
{% highlight java %}
class Foo {

}
{% endhighlight %}
</td>
<td>
{% highlight java %}
class Foo {
    Foo() {
        super();
    }
}
{% endhighlight %}
</td>
</tr>


</table>

__2.__ Every constructor has, as its first statement, either a __call to an overloaded constructor (`this()`) or a call to the
superclass constructor (`super()`)__, and if not it is inserted by the compiler. Remember, compiler __always inserts a _no-arg_
call to `super()`__, it never passes any arguments.


<table>

<tr>
<td>
{% highlight java %}
class Foo {
    Foo() { }
}
{% endhighlight %}
</td>
<td>
{% highlight java %}
class Foo {
    Foo() {
        super();
    }
}
{% endhighlight %}
</td>
</tr>

</table>


__3.__ If you want a no-arg constructor and you've typed any other constructor(s) into your class code, the __compiler won't
provide the no-arg constructor (or any other constructor)__ for you. In other words, if you've typed in a constructor with
arguments, you won't have a no-arg constructor unless you type it in yourself.


<table>

<tr>
<td>
{% highlight java %}
class Foo {
    Foo(String s) {
        super();
    }
}
{% endhighlight %}
</td>
<td>
Code is the same. Compiler doesnâ€™t insert anything here.
</td>
</tr>

</table>

__4.__ Constructors can use __any access modifier, including private__. (A private constructor means only code within the
class itself can instantiate an object of that type, so if the private constructor class wants to allow an instance of
the class to be used, the class must provide a static method or variable that allows access to an instance created
from within the class. Moreover, for a Singleton you are bound to make all constructors of class private.) Also note that
the default constructor has the same access modifier as the class.

<table>

<tr>
<td>
{% highlight java %}
public class Foo {

}
{% endhighlight %}
</td>
<td>
{% highlight java %}
public class Foo {
    public Foo() {
        super();
    }
}
{% endhighlight %}
</td>
</tr>


<tr>
<td>
{% highlight java %}
private class Foo {

}
{% endhighlight %}
</td>
<td>
{% highlight java %}
private class Foo {
    private Foo() {
        super();
    }
}
{% endhighlight %}
</td>
</tr>

</table>


__5.__ A call to `super()` can be either a _no-arg_ call or can include arguments passed to the super constructor. But
the compiler always inserts a _no-arg_ call to `super()`. So there would be a problem in the below case:

<table>

<tr>
<td>
{% highlight java %}
class Animal {
    Animal(String name) { }
}
class Horse extends Animal {
    Horse() { }
}
{% endhighlight %}
</td>
<td>
{% highlight java %}
class Animal {
    Animal(String name) { }
}
class Horse extends Animal {
    Horse() {
        super(); // problem!
    }
}
{% endhighlight %}
</td>
</tr>

</table>

As there is no _no-arg_ constructor in Animal class, the call to `super()` (inserted by the compiler) in `Horse` class will
fail. In fact, the compiler won't even compile the code on the left hand side.

You can solve this in two ways, either you can provide a _no-arg_ constructor in `Animal` class or you can
yourself type `super("some name")` as first statement in the constructor in `Horse` class.

__6.__ You cannot make a call to an instance method, or access an instance variable, until after the super constructor
runs. __Only static variables and methods can be accessed as part of the call to super() or this()__.

<table>

<tr>
<td>
{% highlight java linenos %}
public class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    Animal() {
        this(getName()); // ok!
        this(getNickName()); // compiler error!
        getNickName(); // ok!
    }

    static String getName() {
        return "Horse";
    }

    String getNickName() {
        return "Horsie";
    }
}
{% endhighlight %}
</td>
</tr>

</table>

Now let's understand the above code:

* line 9 is ok as the method `getName()` is static so it belongs to the class and can be accessed without
the need of any object of the class.
* line 10 is not ok as the method `getNickName()` is not static and to access such a method you need an object first and
from constructor chaining we know that until and unless super type constructors are called object isn't created.
* line 11 is fine because super type constructors are called before calling `getNickName()`.

### Some more obvious rules which you already know but is worth mentioning

__7.__ __Abstract classes have constructors__, and those constructors are always called when a concrete subclass is
instantiated.

__8.__ __Interfaces do not have constructors__. Interfaces are not part of an object's inheritance tree.

__9.__ A __constructor can be invoked from within another constructor only__. You cannot invoke a constructor
from anywhere else.

__10.__ Lastly, __constructors are never inherited__. They aren't methods. __Constructors can't be overridden__ (because
they aren't methods and only instance methods can be overridden).

{% include responsive_ad.html %}

### Q&A

__Q1.__ What is the output of the below program?

{% highlight java linenos %}
public class Animal {

    String name;

    Animal(String name) {
        this.name = name;
    }

    Animal() {
        this(getName());
    }

    String getName() {
        return "abc";
    }

    public static void main(String[] args) {
        Animal b = new Animal();
        System.out.println(b.name);
    }
}
{% endhighlight %}

A. `abc`  
B. Empty string  
C. Won't compile  
D. Runtime error

__Q2.__ What is the result?

{% highlight java linenos %}
class Top {
    public Top(String s) {
        System.out.print("B");
    }
}

public class Bottom2 extends Top {
    public Bottom2(String s) {
        System.out.print("D");
    }

    public static void main(String[] args) {
        new Bottom2("C");
        System.out.println(" ");
    }
}
{% endhighlight %}

A. BD  
B. DB  
C. BDC  
D. DBC  
E. Compilation fails

__Q3.__ What is the result?

{% highlight java linenos %}
class Alpha {
    static String s = " ";

    protected Alpha() {
        s += "alpha ";
    }
}

class SubAlpha extends Alpha {
    private SubAlpha() {
        s += "sub ";
    }
}

public class SubSubAlpha extends Alpha {

    private SubSubAlpha() {
        s += "subsub ";
    }

    public static void main(String[] args) {
        new SubSubAlpha();
        System.out.println(s);
    }
}
{% endhighlight %}

A. subsub  
B. sub subsub  
C. alpha subsub  
D. alpha sub subsub  
E. Compilation fails  
F. An exception is thrown at runtime

__Q4.__

{% highlight java linenos %}

class Building {
    Building() {
        System.out.print("b ");
    }

    Building(String name) {

        this();
        System.out.print("bn " + name);
    }
}

public class House extends Building {
    House() {
        System.out.print("h ");
    }

    House(String name) {
        this();
        System.out.print("hn " + name);

    }

    public static void main(String[] args) {
        new House("x ");
    }
}
{% endhighlight %}

What is the result?

A. h hn x  
B. hn x h  
C. b h hn x  
D. b hn x h  
E. bn x h hn x  
F. b bn x h hn x  
G. bn x b h hn x  
H. Compilation fails